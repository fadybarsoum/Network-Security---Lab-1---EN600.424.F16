<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is modified by Seth Nielson for creating P-RFC's
    (Playground-RFC's). -->
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml2rfc.ietf.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced. 
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC1950 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1950.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2360 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2360.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml2rfc.ietf.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->




<rfc category="std" docName="playground_messages" ipr="playgroundSpring201601" number="2">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902, playgroundSpring201601
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

   <title abbrev="Messages">Playground Messages</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Seth James Nielson" initials="S.J." role="editor"
           surname="Nielson">
     <organization>JHU Network Security Spring 2016</organization>

     <address>
       <postal>
         <street>JHU 224 Croft Hall/3400 North Charles St.</street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 410-497-7384</phone>

       <email>sethjn@gmail.com</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

   <date year="2016" />

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>General</area>

   <workgroup>Playground Experiment Director</workgroup>

   <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>Messages, Serialization, Deserialization</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
     <t>The PLAYGROUND (Poly-Localized Algorithmic Yields
     Generated Remotely On Unused Network Devices) system is
     designed to give students and researchers a sandbox in which to develop
     network security experiments. This standard defines 
     the PCC (PLAYGROUND Core Communication) format used for all messages and packets
     used in core PLAYGROUND protocols. This format is optimized for easy 
     serialization and deserialization.</t>
   </abstract>
 </front>

 <middle>
   <section title="Introduction">
     <t>The PLAYGROUND experiment often requires rapid development
     of new protocols. Accordingly, it is desirable that the definition
     of new messages, along with serialization and deserialization
     routines, be implemented quickly.</t>
     
     <t>The PLAYGROUND Core Communication (PCC) format defines a network
     message structure that enables easy serialization and 
     deserialization. All core PLAYGROUND protocols use messages 
     adhering to this format. Core protocols are those used between
     PLAYGROUND clients and the PLAYGROUND server as well as those
     used for the low-level client-to-client messages. It should be
     noted that messages are further categorized into "protocol messages"
     and "packets". Protocol messages are exchanged between protocol peers.
     Packets are designed for transport "over the (virtual) wire" and 
     are protocol messages with additional error detection support.</t>
     
     <t>In addition to the actual message format, this document
     defines a Python code-based mechanism for quickly specifying the
     fields and field-types of a PCC message. This mechanism is a standard
     way for expressing the defition of a PCC message even if the implementation
     language is not Python.</t>

     <section title="Requirements Language">
       <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in <xref
       target="RFC2119">RFC 2119</xref>.</t>
     </section>
   </section>
   
   <section title="Basic Message Format">
   <t>All of the values stored in the packet are stored according to the Python
   2.7 "struct" format using network (big endian) byte order. For each value,
   the struct format character will be included in parentheses next to the byte
   count. The Python struct module is not required; it is simply a reference
   implementation <xref target="PYSTRUCT">[PYSTRUCT]</xref>.</t>
   
   <t>PCC packets have an extra envelope that  MUST begin with a five element 
   sequence header. The header contains a 4-byte magic number, a 4-byte packet
   length, a 2-byte framing size, a 4-byte framing identifier, and a 4-byte
   checksum. In python struct notation, the sequence is "!IIHII".</t>
   
   <t>The magic number of the pre-header is 0x05080D15.</t>
   
   <t>The length field is the total length of the packet excluding the pre-header.</t>

   <t>The framing size indicates how many bytes are within a frame.</t>

   <t>The framing identifier is a randomly chosen 2**32 value that is inserted after evey frame.</t>

   <t>The crc32 is calculated over everything excluding the header. The algorithm is Adler32 as
   described in <xref target="RFC1950">RFC 1950</xref>.</t>
   
    <figure align="center" anchor="pre_header">
       <preamble>PCC Packet Header</preamble>

       <artwork align="left"><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
| Magic | Len(N)|
+-+-+-+-+-+-+-+-+
| F | Term  |CRC
+-+-+-+-+-+-+-+-+
 32 |    Packet |
+               +
      ...
+   (N bytes)   +
|               |
+-+-+-+-+-+-+-+-+
           ]]></artwork>

       <postamble></postamble>
     </figure>
   
	<t>A protocol message MUST follow the header.</t>

        <t>A protocol message contains 
	two string identifiers for the message ID and the message version.
	Both of these elements have a format of a one-byte (B) m-length followed
	by m-bytes of ASCII characters (s)</t>
	
	<t>The message ID MUST be a human readable, dotted string. Each element of
	the dotted string MUST qualify as an identifier in Python 2.7. This means that
	it must be composed of letters and numbers, not begin with a number, and not
	be a reserved word in Python as of version 2.7 <xref target="PYIDENT">[PYIDENT]</xref>.</t>
	
	<t>An example message ID is "playground.base.RegisterClient".</t>
	
	<t>The version of the message allows message definitions to change over time.
	The version string is of the form "major.minor" where major and minor can both
	be converted to Python integers.</t>
	
	    <figure align="center" anchor="packet_def_header">
       <preamble>Packet Definition Header</preamble>

       <artwork align="left"><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|m| Message ID  |
+-+    ...      +
| (m bytes)     |
+-+-+-+-+-+-+-+-+
|k| Version     |
+-+    ...      +
| (k bytes)     |
+-+-+-+-+-+-+-+-+
           ]]></artwork>

       <postamble></postamble>
     </figure>
	
	<t>Message ID and Version MUST be greater than 0 and less than 256.</t>
	
	<t>The "message body" MUST follow the message-definition header. The message
	body begins with a field called "field count" that represents how many
	other fields are contained within. Field count is 2 bytes (H).</t>
	
	<t>The message body MUST contain exactly as many fields as the value indicated
	in field count.</t>
	
	<t>Each additional field in the message body begins with a 2 byte (H) "Field ID"
	that identifies the field for the message. Each message definition maps the
	field ID to a specific type with appropriate size and semantics.</t>
	
	    <figure align="center" anchor="message body">
       <preamble>Packet Message Body</preamble>

       <artwork align="left"><![CDATA[
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
| l |  Fields   |
+-+-+    ...    +
| (l fields)    |
+-+-+-+-+-+-+-+-+
           ]]></artwork>

       <postamble></postamble>
     </figure>
     
     <section title="Field Types">
     <t>Each field's size is determined by its type.</t>
     <t><list style="empty">
     	<t>BOOL1: A 1 byte (?) value interpreted as a true or false. Numerically, only
     	a value equivalent to 1 is "true". All other values are "false".</t>
     	<t>INT1, INT2, INT4, INT8: A 1 (b), 2 (h), 4 (i), or 8 (q) byte signed integer.</t>
     	<t>UINT1, UINT2, UINT4, UINT8: A 1 (B), 2 (H), 4 (I), or 8 (Q) byte unsigned integer.</t>
     	<t>FLOAT4: A 4 byte (f) floating point number.</t>
     	<t>DOUBLE8: An 8 byte (d) double-precision floating point number.</t>
     	<t>STRING: A 2-byte (H) length n followed by an n-byte ascii string (ns). </t>
     	<t>LIST: A 2-byte (H) length n followed by n list elements. The type of each
     	element is the same, and is fixed and specified in the message definition.</t>
     	<t>STRUCT: A recursive type that is exactly like the message body. It begins
     	with a field count followed by a sequences of fields. The identifiers for these
     	fields is independent of the enclosing message body.</t> 
     </list></t>
     </section>	
	
	</section>
   
   <section title="Serialization and Deserialization">
   <t>A message definition can indicate any limitation on a field. A "REQURED" or "OPTIONAL"
   attribute is required although it defaults to REQUIRED if unspecified. A conforming
   implementation MUST enforce all definition limitations during serialization and
   deserialization or signal an error. A conforming implementation MUST check the size
   of the data (including the number of fields in a message body, characters in a string,
   or elements in a list) before serialization or after deserialization.</t>
	</section>
	
	<section title="Message Definition Specification">
	<t>For ease of specifying message definitions, a Python class structure is used
	in the following format:</t>
	
     <figure>
       <preamble></preamble>

       <artwork><![CDATA[
class <<Class Name>>(MessageDefinition):
  PLAYGROUND_IDENTIFIER = <<Full Message ID>>
  MESSAGE_VERSION = <<Full Version>>
    
  class <<Recursive Class Name>>:
    BODY = [
      (<<field name>>, <<field type>>, <<modifiers>>),
        ...
      (<<field name>>, <<field type>>, <<modifiers>>)
    ]
    
  BODY = [
    (<<field name>>, <<field type>>, <<modifiers>>),
      ...
    (<<field name>>, <<field type>>, <<modifiers>>)
  ]

           ]]></artwork>
     </figure>
     
     <t>Field ID's are mapped to field names in order starting with 1.</t> 
     
     <section title="Automatic Fields">
     <t>All PCC messages MUST include a field for a unique (random) 8-byte (Q) 
     identifier. Because this field is automatically included, it is not
     required in the definition. It is always the last field and so has the
     highest field ID.</t>
     </section>
     
     <section title="Modifiers">
     <t>A Message definition can include any kind of limitation. These
     limitations can be written into the specification of the message
     in normal text. However, for clarity and simplicity, certain
     modifiers can be written directly into the Python definition.</t>
     
     <t><list style="symbols">
     <t>REQUIRED or OPTIONAL</t>
     <t>Bounded(min,max) - The values to this field must fall within the given range</t>
     <t>FixedSize(n) - Applies only to lists; fixes the list's size to n</t>
     <t>DefaultValue(v) - If not explicitly set, the value defaults to v</t>
     </list></t>
   </section>
   </section>

   <section title="Packet Deserialization Error Correction">
   <t>Using framing, it is possible to recover from certain kinds of errors in 
   the deserialization of packets (which are assumed to arrive over a potentially
   error prone channel). No actual error correction can occur on the packet data,
   but it should be possible, at least quite often, to detect that something has
   gone wrong, discard the faulty data, and try to get back on track.</t>

   <t>Obviously, if a packet's checksum is wrong, this is easy.</t>

   <t>But what aobut situations wherein a length was corrupted and the receiving
   device is waiting in vain for the rest of the incorrectly large packet. If
   it weren't for framing, the good packets being received might be lost.</t>

   <t>Because each packet has a frame with a maximum size of 2**16 bytes, a
   terminal identifier (random for each packet) is expected at the end of
   each such sequence. If it is not detected, the bytes are discarded, and
   a proper implementation SHOULD search through the discarded bytes to look
   for the magic number and see if another packet can be processed.</t>
   </section>
   
   <section title="Security Considerations">
   <t>Messages have been designed to be reasonably benign. No arbitrary code
   is executed by their deserialization and serialization.</t>
   </section>
 </middle>

 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <references title="Normative References">
     <!--?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
     &RFC2119;
     &RFC1950;
     
     <reference anchor="PYIDENT"
                target="http://docs.python.org/2/reference/lexical_analysis.html#identifiers">
     <front>
         <title>Python identifier definition. </title>

         <author>
           <organization>Python Software Foundation</organization>
         </author>

         <date year="2016" />
       </front>
     </reference>
     <reference anchor="PYSTRUCT"
                target="http://docs.python.org/2/library/struct.html">
     	<front>
         <title>Python 2.7 "struct" module reference.</title>

         <author>
           <organization>Python Software Foundation</organization>
         </author>

         <date year="2016" />
       </front>
     </reference>
     
   </references>


   <!-- Change Log

v00 2006-03-15  EBD   Initial version

v01 2006-04-03  EBD   Moved PI location back to position 1 -
                     v3.1 of XMLmind is better with them at this location.
v02 2007-03-07  AH    removed extraneous nested_list attribute,
                     other minor corrections
v03 2007-03-09  EBD   Added comments on null IANA sections and fixed heading capitalization.
                     Modified comments around figure to reflect non-implementation of
                     figure indent control.  Put in reference using anchor="DOMINATION".
                     Fixed up the date specification comments to reflect current truth.
v04 2007-03-09 AH     Major changes: shortened discussion of PIs,
                     added discussion of rfc include.
v05 2007-03-10 EBD    Added preamble to C program example to tell about ABNF and alternative 
                     images. Removed meta-characters from comments (causes problems).

v06 2010-04-01 TT     Changed ipr attribute values to latest ones. Changed date to
                     year only, to be consistent with the comments. Updated the 
                     IANA guidelines reference from the I-D to the finished RFC.  
                     
SETH NIELSON:
  Altered for PLAYGROUND AND PRFC's
  2014-01-27 SJN PRFC 1
  -->
 </back>
</rfc>
