


Network Working Group                                    S. Nielson, Ed.
Request for Comments: 2                 JHU Network Security Spring 2016
Category: Standards Track                                  February 2016


                          Playground Messages

Abstract

   The PLAYGROUND (Poly-Localized Algorithmic Yields Generated Remotely
   On Unused Network Devices) system is designed to give students and
   researchers a sandbox in which to develop network security
   experiments.  This standard defines a protocol for reliable message
   delivery and transmission control called Playground Transmission
   Control Lite (PTCL).  PTCL is designed to run over C2C, transparently
   providing for upper layers a reliable transmission that guarantees
   delivery, order, and message integrity.

Status of this Memo

   This document specifies a Playgrounds standards track protocol for
   the Playground Experiment, and requests discussion and suggestions
   for improvements.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) Seth James Nielson (2016).  All Rights Reserved.
























Nielson                      Standards Track                    [Page 1]

RFC 2                           Messages                   February 2016


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Requirements Language  . . . . . . . . . . . . . . . . . . . .  3
   3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   4.  Playground Sliding Window Protocol . . . . . . . . . . . . . .  4
   5.  State Machine  . . . . . . . . . . . . . . . . . . . . . . . .  5
     5.1.  Server . . . . . . . . . . . . . . . . . . . . . . . . . .  8
     5.2.  Client . . . . . . . . . . . . . . . . . . . . . . . . . .  8
     5.3.  Session Transmission . . . . . . . . . . . . . . . . . . .  8
     5.4.  Session Reception  . . . . . . . . . . . . . . . . . . . .  9
     5.5.  Termination-Init State Machine . . . . . . . . . . . . . .  9
     5.6.  Termination-Recv State Machine . . . . . . . . . . . . . . 10
   6.  Message Definitions  . . . . . . . . . . . . . . . . . . . . . 10
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 10
   8.  Normative References . . . . . . . . . . . . . . . . . . . . . 11
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 11
   Intellectual Property and Copyright Statements . . . . . . . . . . 12

































Nielson                      Standards Track                    [Page 2]

RFC 2                           Messages                   February 2016


1.  Introduction

   The PLAYGROUND experiment often will have much traffic traveling
   throughout the network.  It is of utmost importance to be sure that
   parties are connected and know the status of message delivery.  The
   C2C layer, while defining a protocol for basic delivery and
   multiplexing (via ports), provides no guarantees of message
   correctness, in-order delivery, or even delivery itself.

   This standard defines a new protocol that runs on top of C2C called
   Playground Transmission Control Lite (PTCL).  PTCL provides the
   following guarantees:

   o  Delivery

   o  In-order delivery

   o  Message integrity

   Unlike C2C, which is stateless, PTCL introduces sessions.  A PTCL
   session begins with a handshake, encapsulates uni-directional data
   transfer between a client and a server, and ends with a disconnect
   routine.  Messages within the session have a sequence number to
   ensure in-order delivery, a HASH to ensure that the message is
   correct, and are acknowledged to confirm reception.

   This document defines both the state machine of the protocol and the
   message formats sent between two PTCL peers.


2.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [RFC2119].


3.  Terminology

   o  Client: Node initiating connection to another node

   o  Server: Node listening for incoming connection or connections on a
      C2C port

   o  Peer: The other node in the connection

   o  Sending data: transmitting DATA packets to the peer




Nielson                      Standards Track                    [Page 3]

RFC 2                           Messages                   February 2016


   o  Delivering data: returning data (received from the network) to the
      application layer

   o  Handshake: Initialization routine used to start a PTCL session
      between two peers

   o  Session: All data transmitted between two peers guaranteed to be
      delivered in-order, without error

   o  Session Close: Termination routine that marks the end of a session

   o  Session Abort: Terminatine procedure when PTCL guarantees cannot
      be met


4.  Playground Sliding Window Protocol

   The Sliding Window protocol is a way to implement the concept of
   Cumulative Acknowledgement.  Cumulative ACK is an attempt at avoiding
   the busy wait created by regular TCP's Send, Ack, Send method.
   Depending on whether it is located on the sender or receiver side,
   the window of the protocol has a different purpose.  The window on
   the sender end contains the maximum number of packets that the sender
   can send without needing to wait for an ACK message.  A receiver's
   window contains the maximum number of packets a sender can buffer out
   of order.  Once full, the receiver window will discard the packets
   received.

   The Protocol: Sender Side

   The Sliding window on the sender side means that the sender would
   "slide" the window of the unacknowledged packets as ACK's for them
   are received.  If the sender receives an ACK for a packet with
   sequence number higher than the first packet in the window, the
   sender will assume that all packets obtained before the ACK'd once
   have been successfully delivered.  The window will move accordingly
   as the interaction with both entities goes on.

   Start: Post handshake

   |..............

   |1|2|3|4|5|6|7|

   Packet 1 ACK Received

   ..|............




Nielson                      Standards Track                    [Page 4]

RFC 2                           Messages                   February 2016


   |1|2|3|4|5|6|7|

   Packet 5 ACK Received

   ..........|....

   |1|2|3|4|5|6|7|

   |.|............

   Scenarios for when an ACK is received for a packet that has already
   been ACked: 1) THe ACK received belongs to a delayed packet (i.e.
   outside of the current window). 2) The packet sent post ACK has not
   been received by the receiver.  In other words, the packet is being
   ACK'd is one less than the lowest sequence in the window.  Here it
   means that the next packet needs to be resent again.

   The Protocol: Receiver Side

   The receiver only sends ACK messages to the sender for the last
   contiguously received packet.  If the receiver obtains packets out of
   order, it sends an ACK for the last contiguously received packet.
   Out of order packets will be buffered in the "window" on the receiver
   side.  The window here is the maximum out of order packets that the
   receiver can accept.

   The criteria for initiation an ACK in expiry of a timer.  Every time
   a packet is received in order, it is processed (see the state
   machine) and teh timer is reset.  If packets are received out of
   order, the timer is not reset and is allowed to expire thereby
   initiating a resend of the last contiguiously received packet.

   Multiple ACK of of the same packet would produce the sender to resend
   the packet which is after the packet being ACK'd.


5.  State Machine

   Message Header Format:

   [HASH][MESSAGE_TYPE][MESS_SEQ][ACK_SEQ]

   Message Types: SYN, SYNACK, ACK, DATA, FIN, FINACK

   Handshake:

   Client State Machine




Nielson                      Standards Track                    [Page 5]

RFC 2                           Messages                   February 2016


   State Event Action Next State

   CONNECTING --- Send SYN CONNECTING

   CONNECTING TIMEOUT Send SYN CONNECTING

   CONNECTING SYNACK received Send ACK SENDRECV

   Server State Machine

   State Event Action Next State

   LISTENING TIMEOUT --- LISTENING

   LISTENING SYN received Send SYNACK CONNECTING

   CONNECTING TIMEOUT Send SYNACK CONNECTING

   CONNECTING ACK received --- SENDRECV

   Transmission--Receiver

   Callbacks:

   packet_received(Packet packet)

   if packet.messageType == DATA

   #Add the received packet to the window

   window.add( packet )

   #Pop as many in-order packets as possible

   #from the front of the window to the application layer

   num_delivered = window.deliver()

   #If packets were received in order, then we do not need to send an
   ACK for now

   if num_delivered >0

   timer.reset()

   timeout()

   #Send ACK for the current highest sequence packet delivered



Nielson                      Standards Track                    [Page 6]

RFC 2                           Messages                   February 2016


   send_ack ( seq )

   #Reset the timer

   timer.reset()

   Transmission--Sender

   Callbacks:

   packet_received(Packet packet)

   #ACK received

   if packet.messageType == "ACK"

   #Clear packets up to (and including) the ACKed sequence from the
   window

   window.clear( packet.seq)

   #Restransmit the packet with the next sequence

   retransmit( window.getPacket( packet.seq+1))

   #If there is room in the window, send more data packets

   while not window.isFull()

   next_packet = makeNextPacket()

   sendPacket (next_packet)

   window.add(next_packet)

   timeout()

   #Retransmit last unacked packet

   Retrasnmitrtransmit (window.firstPacket()

   #If there is room in the window, send more data packets

   while not window.isFull()

   next_packet = makeNextPacket()

   sendPacket( next_packet )



Nielson                      Standards Track                    [Page 7]

RFC 2                           Messages                   February 2016


   window.add( next packet)

5.1.  Server

   Server starts out in LISTENING state

   Server receives a SYN packet and enters the HANDSHAKE state

   Server sends an ACK packet with a starting sequence number
   (SEQ_START).  TODO: How chosen?

   Server receives a SYNACK packet with a starting sequence number
   (PEER_SEQ_START) and enters the SESSION-WAIT state.

   State machine within the session state is the same for client and
   server.  TODO: Is this section organized well?

5.2.  Client

   Client starts out in CONNECTING state

   Client sends a SYN packet.

   Client receives an ACK packet with a starting sequence number
   (PEER_SEQ_START) and enters the HANDSHAKE state.  TODO: Differentiate
   handshake state?

   Client sends a SYNACK packet with a starting sequence number
   (SEQ_START) and enters the SESSION-WAIT state.  TODO: How chosen?

   State machine within the session state is the same for client and
   server.

   TODO: Timeouts?  Error state?

5.3.  Session Transmission

   Node receives data from upper protocol.  Enters the SESSION-TRANSMIT
   state.

   Node fragments data.  TODO: Flesh out

   Node transmits up to TRANSMISSION_WINDOW packets.  Each packet has a
   sequence number starting at SEQ+1, increasing monotonically up to
   SEQ+TRANSMISSION_WINDOW.  SEQ is set to SEQ+TRANSMISSION_WINDOW.
   Node enters the SESSION-NEEDS_ACK state.  TODO: what do we do with
   data that can't be sent?  Buffer? what if Upper layer tries to send
   data while in NEEDS_ACK state?  Should we think of it as two state



Nielson                      Standards Track                    [Page 8]

RFC 2                           Messages                   February 2016


   machines (one in the TRANSMISSION state and one in the NEEDS_ACK
   state) or one machine with a TRANS_ACK state?

   Node receives a HB packet with MAX_SEQ_RECV and MISSING_SEQ.  If
   MAX_SEQ_RECV is equal to SEQ, and MISSING_NUMS is empty, Node re-
   enters SESSION-WAIT.  Else, it retransmits each packet in
   MISSING_SEQ, and from MAX_SEQ_RECV+1 up to SEQ.  The HASH value of
   the entire packet is in SHA256

   TODO: fragment index not specified, storing not specified, timeout
   not specified, sequence number overflow not specified.

5.4.  Session Reception

   Node transmits HeartBeat message every HB_PERIOD seconds.  Heartbeat
   has a MAX_SEQ_RECV value equal to the last SEQ received from the
   peer.  Because the ACK or SYNACK packet has a SEQ number, the
   Heartbeat always has a last SEQ.  The Hearbeat also carries a
   MISSING_SEQ list with any packets less than MAX_SEQ_RECV that need to
   be resent.

   Node receives data from peer.  Enters the SESSION-RECEPTION state.
   HeartBeat messages are sent every HB_DATA_PERIOD seconds.

   Node receives up to RECEPTION_WINDOW packets from network.  If
   packets are not fragmented, or all fragments are received in order,
   the node passes the data to the upper layer.  This does not reduce
   the count of packets received.

   If the number of packets received exceeds RECEPTION_WINDOW before
   HB_DATA_PERIOD, The node sends the next HeartBeat early.

   If the number of packets received does not exceed RECEPTION_WINDOW,
   acks are sent in HeartBeat message on scheduled HB_DATA_PERIOD
   transmission.

   When all packets received are acknowledged, Node returns to SESSION-
   WAIT state.

   TODO: I think it makes sense to describe transmit and receive as two
   separate state machines.  But we can make it one if you want?

5.5.  Termination-Init State Machine

   Node is closed by upper layer.  Node enters SHUTDOWN state.  TODO:
   What happens to Messages being sent and being received?

   Node transmits FIN and enters SHUTDOWN-WAIT state.



Nielson                      Standards Track                    [Page 9]

RFC 2                           Messages                   February 2016


   Node receives FIN-ACK and terminates.

   TODO: resend? retry?

5.6.  Termination-Recv State Machine

   Node receives FIN and enters SHUTDOWN state.

   Node transmits FIN-ACK and terminates.

   TODO: See others


6.  Message Definitions

   Fill in text explaining all the pieces


   class PTCLMessage(MessageDefinition):
     PLAYGROUND_IDENTIFIER = "playground.base.PTCLMessage"
     MESSAGE_VERSION = "1.0"

     BODY = [
       ("Checksum", STRING),
       ("MessageType", STRING),
       ("Seq", UINT8),
       ("Data", STRING)]
     ]


   o  MessageType is one of "SYN", "ACK", "SYNACK", "DATA", "FIN",
      "FINACK"

   o  If message type is syn, fin, or finack, SEQ/DATA not set

   o  If message type is synack or ack, SEQ is set, but not data

   o  If message type is data, all fields are set


7.  Security Considerations

   Messages have been designed to be reasonably benign.  No arbitrary
   code is executed by their handshake process.  It is important to note
   that the measures taken by this protocol to guarantee reliability
   does not make the network become resistant against adversaries.
   Message integrity here (which is enforced by the HASH) allows random
   errors introduced to data packets to be detected and be recovered



Nielson                      Standards Track                   [Page 10]

RFC 2                           Messages                   February 2016


   from.  The threat model of PTCL is as follows: Assessment scope -
   What is on the line here is the function of the network to ensure
   data can be sent from the sender to the receiver as intended.  Threat
   agents - Existing Countermeasures - Vulnerabilities - Prioritized
   Risks - New Countermeasures - We talk about message integrity, but
   against what?  Also, we should put something about the policy in here
   maybe.  If not here (because it really isnt a security policy), maybe
   in the intro?  Or a separate section?


8.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, DOI 10.17487/
              RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.


Author's Address

   Seth James Nielson (editor)
   JHU Network Security Spring 2016
   JHU 160 Malone Hall/3400 North Charles St.
   Baltimore, MD  21218
   USA

   Phone: +1 410-497-7384
   Email: sethjn@gmail.com























Nielson                      Standards Track                   [Page 11]

RFC 2                           Messages                   February 2016


Full Copyright Statement

   Copyright (C) Seth James Nielson (2016).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the PLAYGROUND experiment or
   other associated organizations, except by explicit permission.

   The limited permissions granted above are perpetual and will not be
   revoked by SETH JAMES NIELSON or his successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and SETH JAMES NIELSON and associated academic
   institutions DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The PLAYGROUND framework and student submissions for PLAYGROUND are
   intended to be free of any intellectual property conflicts.  All
   submitting parties, especially students, are not allowed to submit
   source code, specifications, or other components that are known to be
   protected by copyright, patents, or other IP mechanisms.  Students
   submitting creative content grant shared rights and ownership of
   their content to the PLAYGROUND project.  Specifically, any
   submission can be used in future educational settings including
   subsequent PLAYGROUND experiments.

   Any interested party is invited to bring to the experiment director's
   attention any copyrights, patents or patent applications, or other
   proprietary rights which may cover technology that may be currently
   in use without permission.

   It should be noted that these statements have not been reviewed by
   legal counsel.  Moreover, the academic institutions at which
   PLAYGROUND experiments take place may have additional or even
   conflicting copyright and intellectual property rules.  Accordingly,
   concerned parties may need to contact their own lawyer and/or
   resources at their institution to understand the rights and



Nielson                      Standards Track                   [Page 12]

RFC 2                           Messages                   February 2016


   limitations associated with code donated to a PLAYGROUND experiment.


















































Nielson                      Standards Track                   [Page 13]

