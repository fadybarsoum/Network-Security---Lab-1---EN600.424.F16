<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is modified by Seth Nielson for creating P-RFC's
    (Playground-RFC's). -->
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml2rfc.ietf.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced. 
    An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC1950 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1950.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2360 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2360.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
    please see http://xml2rfc.ietf.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->




<rfc category="std" docName="playground_messages" ipr="playgroundSpring201601" number="2">
 <!-- category values: std, bcp, info, exp, and historic
    ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
       or pre5378Trust200902, playgroundSpring201601
    you can add the attributes updates="NNNN" and obsoletes="NNNN" 
    they will automatically be output with "(if approved)" -->

 <!-- ***** FRONT MATTER ***** -->

 <front>
   <!-- The abbreviated title is used in the page header - it is only necessary if the 
        full title is longer than 39 characters -->

   <title abbrev="Messages">Playground Messages</title>

   <!-- add 'role="editor"' below for the editors if appropriate -->

   <!-- Another author who claims to be an editor -->

   <author fullname="Seth James Nielson" initials="S.J." role="editor"
           surname="Nielson">
     <organization>JHU Network Security Spring 2016</organization>

     <address>
       <postal>
         <street>JHU 224 Croft Hall/3400 North Charles St.</street>

         <!-- Reorder these if your country does things differently -->

         <city>Baltimore</city>

         <region>MD</region>

         <code>21218</code>

         <country>USA</country>
       </postal>

       <phone>+1 410-497-7384</phone>

       <email>sethjn@gmail.com</email>

       <!-- uri and facsimile elements may also be added -->
     </address>
   </author>

   <date year="2016" />

   <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
        in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

   <!-- Meta-data Declarations -->

   <area>General</area>

   <workgroup>Playground Experiment Director</workgroup>

   <!-- WG name at the upperleft corner of the doc,
        IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
        which is used by the RFC Editor as a nod to the history of the IETF. -->

   <keyword>Messages, Serialization, Deserialization</keyword>

   <!-- Keywords will be incorporated into HTML output
        files in a meta tag but they have no effect on text or nroff
        output. If you submit your draft to the RFC Editor, the
        keywords will be used for the search engine. -->

   <abstract>
     <t>The PLAYGROUND (Poly-Localized Algorithmic Yields
     Generated Remotely On Unused Network Devices) system is
     designed to give students and researchers a sandbox in which to develop
     network security experiments. This standard defines 
     the PCC (PLAYGROUND Core Communication) format used for all messages and packets
     used in core PLAYGROUND protocols. This format is optimized for easy 
     serialization and deserialization.</t>
   </abstract>
 </front>

 <middle>
   <section title="Introduction">
     <t>The PLAYGROUND experiment often will have much traffic traveling
     throughout the network. It is of utmost importance to be sure that
     parties are connected and know the status of message delivery. 
    </t> 
     <t>The PLAYGROUND Core Communication (PCC) format defines a network message 
     structure that utilizes a handshake similar to that of TCP to establish a
     connection, but uses additional verification to let the sender know that
     data has been received. Once there is no more data to be sent, an end of data
     message is sent to the recipient. A disconnect handshake occurs to close the 
     connection. Because errors can always occur, messages are resent in the event
     that a confirmation (ACK) message has not been received to proceed with
     communication. 
     </t>

     <t>In addition to the actual message format, this document
     defines a Python code-based mechanism for quickly specifying the
     fields and field-types of a PCC message. This mechanism is a standard
     way for expressing the defition of a PCC message even if the implementation
     language is not Python.
     </t>
   </section>

     <section title="Requirements Language">
       <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
       "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
       document are to be interpreted as described in <xref
       target="RFC2119">RFC 2119</xref>.</t>
     </section>

   <section title="Terminology">
     <t>Client: host initiating connection between two entities</t>
     <t>Server: host listening for incoming connection or connections as 
     Playground allows for multiple clients connecting to a server.</t>
     <t>Sending data: transmitting DATA packets to a host(Client, Server, or
     Both) accross the PLAYGROUND network.</t>
     <t>Delivering data: returning data (received from the network) to the 
     application layer </t> 
     <t>SYN: start connection</t>
     <t>ACK: acknowledges that message received</t>
     <t>DATA: data sent accross network</t>
     <t>FIN: no more data left to send</t>

   </section>   
   <section title="Basic Message Format">
   <t>All of the values stored in the packet are stored according to the Python
   2.7 "struct" format using network (big endian) byte order. For each value,
   the struct format character will be included in parentheses next to the byte
   count. The Python struct module is not required; it is simply a reference
   implementation <xref target="PYSTRUCT">[PYSTRUCT]</xref>.</t>
   
   <t>PCC packets have an extra envelope that  MUST follow the following format
   
    <figure align="center" anchor="pre_header">
       <preamble>PCC Packet Header</preamble>

       <artwork align="left"><![CDATA[
 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
|MESSAGE TYPE|SEQUENCE NUMBER|ACK NUMBER| DATA HASH|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
           ]]></artwork>

       <postamble></postamble>
     </figure>
   </t>
  <t>There is a total of four types of Message Types: SYN, ACK, DATA, and FIN. 
  SYN is the message type involved when starting up a connection. ACK is a 
  confirmation message (a client or server) sends in confirmation of receiving
  a SYN, DATA, or FIN message. DATA messages are those which send data accross the
  network. FIN messages are those engaged in closing a connection
  </t>
  <t>
  Sequence numbers and Ack numbers serve as identifiers between the Client and Server
  during communications. The values serve as identifiers between the Client and Server.
  There are Five stages within a Client's State Machine: START, CONNECTING, SEND or RECEIVE, and FINISHING. Three types of handshake sequences occur within a Client-Server communication. 
  </t>
  <t>
  START and CONNECTING exist during the Start-Up handshake sequence. SEND or RECEIVE during the
  Data Transmission sequence. FINISHING within the Shut-Down sequence. Figures 2-4 show the three
  Handshake Sequences. Figure 5 shows what a Client State Machine looks like. 
  </t>
 <t> A typical 1) initiates the connection. 2) Re-sends request if no response received. 
     3) Complete Start-Up handshake. 4) Send data accross connection once ready. 5) When host 
     sends data to the application, ACK the highest sequence number of the data is delievered. 
     6) If no response received, re-send Data. 7) Keep going until no more data needs to be sent. 
     8) Start Shut-down handshake.  
 </t>
  <t>Handshakes:
    <figure align = "center">
     <preamble> Startup Handshake </preamble>
     <artwork align = "left"> <![CDATA[
           Client                                 Server
      [SYN][S1][0][H()]    ------------> 
                              -----------[[ACK][S2][S1][H()]
      [ACK][S1=S1+1][S2][H()] ------------>
      ]]></artwork>
   </t>
  <t> A client chooses S1 and sends the SYN to the server. The Server chooses S2 and sends
   an ACK acknowledgement  to the client confirming that it received the clients message. 
   The client increments S1 by 1, sends its own ACK to the server. 
  </t>
 
   <t>Data Transmission:                               
           Client                                 Server
      [DATA][S1=S1+1][S2][H()]    ------------>
                              -----------[[ACK][S2][S1][H()]
      [ACK][S1=S1+1][S2][H()] ------------>

      
   Client sends DATA to the Server, client chooses S1 and sends the SYN to the server. The Server
   sends an ACK acknowledgement  to the client confirming that it received the clients message.
   The client increments S1 by 1, sends its own ACK to the server.

   This keeps going until no more data is available to send. Once that occurs, the Shutdown Handshake sequence commences.
   </t>

   <t>Shutdown Handshake:
           Client                                 Server
      [FIN][S1=S1+1][0][H()]    ------------>
                              -----------[[ACK][S2][S1][H()]

   A client keeps incrementing S, no data is left over to send, and sends a FIN to the server.
   The server sends an ACK acknowledgement  to the client confirming that it received the clients
   message. The client increments S1 by 1, sends its own ACK to the server.
   </t>
 


   </section>

	
	<section title="Message Definition Specification">
	<t>For ease of specifying message definitions, a Python class structure is used
	in the following format:</t>
	
     <figure>
       <preamble></preamble>

       <artwork><![CDATA[
class <<Class Name>>(MessageDefinition):
  PLAYGROUND_IDENTIFIER = <<Full Message ID>>
  MESSAGE_VERSION = <<Full Version>>
    
  class <<Recursive Class Name>>:
    BODY = [
      (<<field name>>, <<field type>>, <<modifiers>>),
        ...
      (<<field name>>, <<field type>>, <<modifiers>>)
    ]
    
  BODY = [
    (<<field name>>, <<field type>>, <<modifiers>>),
      ...
    (<<field name>>, <<field type>>, <<modifiers>>)
  ]

           ]]></artwork>
     </figure>
     
     <t>Field ID's are mapped to field names in order starting with 1.</t> 
     
     
   </section>

   
   <section title="Security Considerations">
   <t>Messages have been designed to be reasonably benign. No arbitrary code
   is executed by their handshake process.</t>
   </section>
 </middle>

 <!--  *****BACK MATTER ***** -->

 <back>
   <!-- References split into informative and normative -->

   <!-- There are 2 ways to insert reference entries from the citation libraries:
    1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
    2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
       (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

    Both are cited textually in the same manner: by using xref elements.
    If you use the PI option, xml2rfc will, by default, try to find included files in the same
    directory as the including file. You can also define the XML_LIBRARY environment variable
    with a value containing a set of directories to search.  These can be either in the local
    filing system or remote ones accessed by http (http://domain/dir/... ).-->

   <references title="Normative References">
     <!--?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
     &RFC2119;
     &RFC1950;
     
     <reference anchor="PYIDENT"
                target="http://docs.python.org/2/reference/lexical_analysis.html#identifiers">
     <front>
         <title>Python identifier definition. </title>

         <author>
           <organization>Python Software Foundation</organization>
         </author>

         <date year="2016" />
       </front>
     </reference>
     <reference anchor="PYSTRUCT"
                target="http://docs.python.org/2/library/struct.html">
     	<front>
         <title>Python 2.7 "struct" module reference.</title>

         <author>
           <organization>Python Software Foundation</organization>
         </author>

         <date year="2016" />
       </front>
     </reference>
     
   </references>


   <!-- Change Log

v00 2006-03-15  EBD   Initial version

v01 2006-04-03  EBD   Moved PI location back to position 1 -
                     v3.1 of XMLmind is better with them at this location.
v02 2007-03-07  AH    removed extraneous nested_list attribute,
                     other minor corrections
v03 2007-03-09  EBD   Added comments on null IANA sections and fixed heading capitalization.
                     Modified comments around figure to reflect non-implementation of
                     figure indent control.  Put in reference using anchor="DOMINATION".
                     Fixed up the date specification comments to reflect current truth.
v04 2007-03-09 AH     Major changes: shortened discussion of PIs,
                     added discussion of rfc include.
v05 2007-03-10 EBD    Added preamble to C program example to tell about ABNF and alternative 
                     images. Removed meta-characters from comments (causes problems).

v06 2010-04-01 TT     Changed ipr attribute values to latest ones. Changed date to
                     year only, to be consistent with the comments. Updated the 
                     IANA guidelines reference from the I-D to the finished RFC.  
                     
SETH NIELSON:
  Altered for PLAYGROUND AND PRFC's
  2014-01-27 SJN PRFC 1
  -->
 </back>
</rfc>
